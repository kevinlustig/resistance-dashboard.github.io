<script type="text/javascript" src="https://d3js.org/d3.v2.min.js"></script>
<style>
  @media (min-width: 768px) {
    #chart .col-sm-2 {
      width: 19%;
    }
  }

  .guage h4 {
    text-align: center;
  }

  .gauge g.arc {
    fill: steelblue;
  }

  .gauge g.pointer {
    stroke: #fff;
  }
  
  .gauge g.label text {
    text-anchor: middle;
    font-size: 14px;
    font-weight: bold;
    fill: #666;
  }
</style>

<div id="chart" class="row">
	<h3 class="section-header">How much should I worry?</h3>
  <div class="col-sm-3">
    <div class="guage">
      
      <div id="rightwing-ideologue"></div>
      <h4>Right-wing Ideologue</h4>
    </div>
  </div>
  
  <div class="col-sm-3">
    <div class="guage">
      
      <div id="racist"></div>
      <h4>Racist</h4>
    </div>
  </div>
  
  <div class="col-sm-3">
    <div class="guage">
      
      <div id="threat-democracy"></div>
      <h4>Threat to Democracy</h4>
    </div>
  </div>

  <div class="col-sm-3">
    <div class="guage">
      
      <div id="nepotisim-selfenricher"></div>
      <h4>Nepotism &amp; Self-Enricher</h4>
    </div>
  </div>
  
</div>

<script>
  var gauge = function(container, configuration) {
    var that = {};
    var config = {
      size                      : 200,
      clipWidth		              : 200,
      clipHeight	              : 110,
      ringInset		              : 20,
      ringWidth		              : 20,
      
      pointerWidth				      : 10,
      pointerTailLength		      : 5,
      pointerHeadLengthPercent	: 0.9,
      
      minValue					        : 0,
      maxValue					        : 10,
      
      minAngle					        : -60,
      maxAngle					        : 60,
      
      transitionMs				      : 750,
      
      majorTicks					      : 5,
      // labelFormat					      : d3.format(',g'),
      textInfo                  : 'text',
      textPosition              : 'inside',
      labelInset					      : 10,
      
      arcColorFn					      : d3.interpolateHsl(d3.rgb('#ffd9d9'), d3.rgb('#8b0000'))
    };
    var range = undefined;
    var r = undefined;
    var pointerHeadLength = undefined;
    var value = 0;
    
    var svg = undefined;
    var arc = undefined;
    var scale = undefined;
    var ticks = undefined;
    var tickData = undefined;
    var pointer = undefined;

    var donut = d3.layout.pie();
    
    function deg2rad(deg) {
      return deg * Math.PI / 180;
    }
    
    function newAngle(d) {
      var ratio = scale(d);
      var newAngle = config.minAngle + (ratio * range);
      return newAngle;
    }
    
    function configure(configuration) {
      var prop = undefined;
      for ( prop in configuration ) {
        config[prop] = configuration[prop];
      }
      
      range = config.maxAngle - config.minAngle;
      r = config.size / 2;
      pointerHeadLength = Math.round(r * config.pointerHeadLengthPercent);

      // a linear scale that maps domain values to a percent from 0..1
      scale = d3.scale.linear()
        .range([0,1])
        .domain([config.minValue, config.maxValue]);
        
      ticks = scale.ticks(config.majorTicks);
      tickData = d3.range(config.majorTicks).map(function() {return 1/config.majorTicks;});
      
      arc = d3.svg.arc()
        .innerRadius(r - config.ringWidth - config.ringInset)
        .outerRadius(r - config.ringInset)
        .startAngle(function(d, i) {
          var ratio = d * i;
          return deg2rad(config.minAngle + (ratio * range));
        })
        .endAngle(function(d, i) {
          var ratio = d * (i+1);
          return deg2rad(config.minAngle + (ratio * range));
        });
    }
    that.configure = configure;
    
    function centerTranslation() {
      return 'translate('+r +','+ r +')';
    }
    
    function isRendered() {
      return (svg !== undefined);
    }
    that.isRendered = isRendered;
    
    function render(newValue) {
      svg = d3.select(container)
        .append('svg:svg')
          .attr('class', 'gauge')
          .attr('width', config.clipWidth)
          .attr('height', config.clipHeight);
      
      var centerTx = centerTranslation();
      
      var arcs = svg.append('g')
          .attr('class', 'arc')
          .attr('transform', centerTx);
      
      arcs.selectAll('path')
          .data(tickData)
        .enter().append('path')
          .attr('fill', function(d, i) {
            return config.arcColorFn(d * i);
          })
          .attr('d', arc);
      
      var lg = svg.append('g')
          .attr('class', 'label')
          .attr('transform', centerTx);
      lg.selectAll('text')
          .data(ticks)
        .enter().append('text')
          .attr('transform', function(d) {
            var ratio = scale(d);
            var newAngle = config.minAngle + (ratio * range);
            return 'rotate(' +newAngle +') translate(0,' +(config.labelInset - r) +')';
          })
          .text(config.labelFormat);

      var lineData = [ [config.pointerWidth / 2, 0], 
              [0, -pointerHeadLength],
              [-(config.pointerWidth / 2), 0],
              [0, config.pointerTailLength],
              [config.pointerWidth / 2, 0] ];
      var pointerLine = d3.svg.line().interpolate('monotone');
      var pg = svg.append('g').data([lineData])
          .attr('class', 'pointer')
          .attr('transform', centerTx);
          
      pointer = pg.append('path')
        .attr('d', pointerLine/*function(d) { return pointerLine(d) +'Z';}*/ )
        .attr('transform', 'rotate(' +config.minAngle +')');
        
      update(newValue === undefined ? 0 : newValue);
    }
    that.render = render;
    
    function update(newValue, newConfiguration) {
      if ( newConfiguration  !== undefined) {
        configure(newConfiguration);
      }
      var ratio = scale(newValue);
      var newAngle = config.minAngle + (ratio * range);
      pointer.transition()
        .duration(config.transitionMs)
        .ease('elastic')
        .attr('transform', 'rotate(' +newAngle +')');
    }
    that.update = update;

    configure(configuration);
    
    return that;
  };
</script>

<script>
  function onDocumentReady() {
    var rightwingGauge = gauge('#rightwing-ideologue', {
      minValue: 0,
      maxValue: 10,
      size: 300,
      clipWidth: 300,
      clipHeight: 300,
      ringWidth: 60,
      maxValue: 10,
      transitionMs: 4000,
      arcColorFn: d3.interpolateHsl(d3.rgb('#ffbf00'), d3.rgb('#997200'))
    });
    rightwingGauge.render();
    
    var racistGauge = gauge('#racist', {
      minValue: 0,
      maxValue: 10,
      size: 300,
      clipWidth: 300,
      clipHeight: 300,
      ringWidth: 60,
      maxValue: 10,
      transitionMs: 4000,
      arcColorFn: d3.interpolateHsl(d3.rgb('#ff8c00'), d3.rgb('#995400'))
    });
    racistGauge.render();
    
    var threatGauge = gauge('#threat-democracy', {
      minValue: 0,
      maxValue: 10,
      size: 300,
      clipWidth: 300,
      clipHeight: 300,
      ringWidth: 60,
      maxValue: 10,
      transitionMs: 4000,
    });
    threatGauge.render();
    
    var nepotisimGauge = gauge('#nepotisim-selfenricher', {
      minValue: 0,
      maxValue: 10,
      size: 300,
      clipWidth: 300,
      clipHeight: 300,
      ringWidth: 60,
      maxValue: 10,
      transitionMs: 4000,
      arcColorFn: d3.interpolateHsl(d3.rgb('#32cd32'), d3.rgb('#1e7b1e'))
    });
    nepotisimGauge.render();
    
    var governingGauge = gauge('#personal-governing-capacity', {
      minValue: 0,
      maxValue: 10,
      size: 300,
      clipWidth: 300,
      clipHeight: 300,
      ringWidth: 60,
      maxValue: 10,
      transitionMs: 4000,
      arcColorFn: d3.interpolateHsl(d3.rgb('#fb6076'), d3.rgb('#963946'))
    });
    governingGauge.render();
    
    function updateReadings() {
      // just pump in random data here...
      rightwingGauge.update(5);
      racistGauge.update(3);
      threatGauge.update(2);
      nepotisimGauge.update(8);
      governingGauge.update(6);
    }
    
    // every few seconds update reading values
    updateReadings();
  }

  if ( !window.isLoaded ) {
    window.addEventListener("load", function() {
      onDocumentReady();
    }, false);
  } else {
    onDocumentReady();
  }
</script>